# 2️⃣ 관계 모델

관계 모델에서 데이터의 표현은 릴레이션으로 구성되며, 릴레이션은 릴레이션 스키마와 릴레이션 인스턴스로 이루어진다.
### ✔︎ 릴레이션 스키마
스키마: 어떠한 객체의 구성을 표현한 메타데이터

**릴레이션 스키마**: 개체(Entity) 와 개체의 특성을 나타내는 속성(Attribute) , 개체 간의 관계(Relation) , 이들의 제약 조건(Constraint) 을 기술한 것
<img src="config/image10.png">
- 릴레이션 스키마 명세
  - 릴레이션 이름
  - 필드(Field) 또는 열(Column) , 또는 속성(Attribute) 의 이름
  - 각 속성의 도메인(Domain) 이름

### ✔︎ 릴레이션 인스턴스
릴레이션 인스턴스(Relation Instance) 는 **레코드(Record)** 라고도 하는 **투플(Tuple) 의 집합**이며, 각 투플은 릴레이션 스키마에서 정의된 필드로 구성된다.
- **레코드(Record)** 라고도 불리는 투플(Tuple) 의 집합
- **투플(Tuple)**: 릴레이션 스키마에서 정의된 각 속성(필드) 로 정의된, 하나의 데이터 묶음
  - 릴레이션 인스턴스에서는 각 투플을 하나의 행(row) 으로 구성
- 릴레이션 인스턴스의 투플 수: `카디널리티(Cardinality)`
- 릴레이션 인스턴스의 속성(필드) 수: `차수(Degree 또는 Arity)`
  - 릴레이션 인스턴스의 투플 순서는 중요하지 않음

### ✔︎ 도메인
- 하나의 속성이 가질 수 있는 동일한 유형의 원자값들의 집합
  - 원자값: 쪼갤 수 없음
- 릴레이션 스키마는 릴레이션 인스턴스의 각 필드의 도메인을 명세(도메인 제약조건)
- 프로그래밍 언어 관점에서 필드의 데이터 타입을 의미
- `R(fi:D1, … fn:Dn) `을 릴레이션 스키마라고 하고, 각 `fi, 1 ≤ i ≤ n` 에 대한 이름이 `Di` 인 도메인에 대한 집합을 `Domi` 이라고 할 때, 도메인 제약조건을 만족하는 R의 인스턴스는 다음과 같이 n개의 필드를 가진 투플의 한 집합이 됨
  - `{ <fi: di, … fn: dn> | d1 ∈ Dom1, … dn ∈ Domn}`

### 관계 데이터베이스
**관계 데이터베이스(Relational Database)**: 서로 다른 릴레이션 이름을 가진 릴레이션들의 모임

**관계 데이터베이스 스키마(Relational Database Schema)**: 데이터베이스에 속한 릴레이션의 스키마들의 집합

---
## 💡 Lab 2-1a : SQL을 사용한 릴레이션 생성 및 수정 (MySQL)
릴레이션 스키마를 가진 두 릴레이션을 생성한다.
- Category(CategoryNo: Integer, CategoryName: String)
- Product(ProductNo: Integer, ModelNumber: String, ProductName: String, Price: float, CategoryNo: Integer)


1. Category 테이블에 데이터를 입력
   <img src="config/image12.png">

2. Category 릴레이션의 데이터를 수정
   <img src="config/image13.png">

3. Category 릴레이션의 데이터를 다시 수정
   <img src="config/image14.png">

4. Category 테이블의 CategoryNo 필드의 데이터를 수정
   <img src="config/image11.png">

---
## 무결성 제약조건
- **개체 무결성** > 키 제약조건
    - unique: 후보키 관련 조건
- **참조 무결성** > 외래키 제약조건
- **도메인 무결성** > 도메인 제약조건
    - check 제약 조건

-----

### 1. 개체 무결성
각 개체는 데이터베이스 내에서 유일해야 한다는 의미에서 개체 무결성(Entity Integrity) 라고 한다. 개체 무결성을 위해 키 제약조건(Key Constraint) 을 사용한다. 키 제약조건은 릴레이션에 속한 필드들의 어떠한 최소 부분집합이 각 투플에 대해 고유한 식별자가 된다는 선언이다.

- 한 개체(투플)는 다른 개체들과 명확히 구분되어야 함
- 모든 릴레이션에 속한 필드들의 최소 부분집합이 각 투플에 대해 고유 식별자가 되어야 함
- 릴레이션에 속한 필드들의 최소 부분 집합이 각 투플에 고유한 식별자가 되어야 함
- 키 제약조건에서 투플을 식별하는 부분집합을 키(Key)라고 함

#### 키(Key)
적법한 인스턴스의 서로 다른 두 투플은 한 키에 속하는 모든 필드 전체에 대해 동일한 값을 가질 수 없다.

키를 구성하는 필드 집합의 어떠한 부분집합도 투플에 대해 유일한 식별자가 될 수 없다.
- **수퍼 키(Super Key)**: 유일성을 만족하는, 필드들의 부분 집합
- **후보 키(Candidate Key)**: 유일성과 최소성을 만족하는 수퍼키 집합의 부분 집합
- **기본 키(Primary Key)**: 특정 투플을 구별하기 위해 후보 키에서 선택된 고유한 식별자

### 2. 참조 무결성
한 릴레이션에 저장된 정보와 다른 릴레이션에 저장된 정보가 연결되는 경우가 대부분
이다. 참조 관계에 있는 두 릴레이션의 데이터는 항상 일관된 값으로 유지되어야 한다.
- **외래 키 제약조건(Foreign Key Constraint)** 으로 참조 무결성을 유지
    - 한 릴레이션의 필드가 다른 릴레이션의 키를 참조
    - 참조하는 릴레이션의 데이터 변경에 따른 무결성을 유지
- **외래 키(Foreign Key)**
    - 한 릴레이션의 키 중에서 다른 릴레이션의 투플을 유일하게 식별할 수 있는 키
    - 한 릴레이션의 투플에서 다른 릴레이션의 투플을 참조하기 위해 사용

### 3. 도메인 무결성
릴레이션 스키마는 릴레이션 인스턴스의 각 필드에 저장될 수 있는 데이터의 범위인 도메인을 명세한다.
릴레이션의 각 속성(필드) 에는 범위에 지정된 **일관된 데이터만 저장**되어야 하며, 이를 **도메인 무결성(Domain Integrity)** 이라고 한다.

도메인 무결성은 각 속성(필드)에 지정된 도메인의 범위를 벗어나는 값을 저장할 수 없도록 하는 제약 조건인 도메인 제약조건(Domain Constraint) 로 유지된다.
- 릴레이션의 각 속성에 포함되는 데이터의 형식을 제약
    - 각 속성의 값은 반드시 원자값이어야 함
    - 속성에 지정된 도메인의 범위 내에 해당하는 값이어야 함
    - 속성의 기본 값과 null 포함 가능 여부등에 대한 제약조건

### 무결성 제약조건 집행
제약조건들은 릴레이션 스키마에 정의되고 생성할 때 명세되며 릴레이션이 수정될 때 집행된다.

도메인 무결성을 유지하기 위한 도메인 제약조건과 개체 무결성을 유지하기 위한 기본 키 제약조건과 Unique 제약조건은 직관적으로, 이들 제약조건을 위배하는 삽입, 삭제, 갱신 명령은 즉시 거부된다.
- 참조 무결성 집행 단계
    - 참조하는 릴레이션에 없는 값에 대한 삽입이 시도되는 경우
    - 명령이 거부됨
    - 참조 릴레이션의 데이터가 삭제되는 경우
    - 외래 키가 존재하는 릴레이션의 참조 데이터를 모두 삭제
    - 참조 릴레이션의 데이터를 삭제할 수 없도록 명령을 거부
    - 외래 키가 존재하는 릴레이션의 해당 데이터를 모두 다른 값으로 갱신
    - 참조하는 릴레이션의 데이터가 변경되는 경우
    - 세 가지 방법 중 하나를 선택
